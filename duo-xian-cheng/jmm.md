JMM介绍

核心概念： 原子性、可见性、重排序、缓存、线程优化、指令重排序、数据安全

JMM Java内存模型,是JVM平台提供给多线程环境下的内存可见、是否可以重排序等无关平台的统一的保证。

多线程开发需要注意3个问题：

原子性、可见性、重排序

原子性是指线程在进行操作的时候是否会受到其他线程的干扰，比如i++操作,是一个复合的操作，如果不能保证原子性，会导致数据安全的问题。

可见性和重排序都是线程优化的问题。

可见性指的是缓存的一致性的问题,CPU都配置了多级高速的缓存来提高性能

典型的CPU缓存结构示意图如下

![](http://static.codeceo.com/images/2017/05/cpu-arch.png)

CPU的指令周期通常为取指令、解析指令读取数据、执行指令、数据写回寄存器或内存。串行执行指令时其中的读取存储数据部分占用时间较长，所以CPU普遍采取指令流水线的方式同时执行多个指令, 提高整体吞吐率，就像工厂流水线一样

#### 重排序

java语言提出了JavaMemoryModel即Java内存模型，对于Java语言、JVM、编译器等实现者需要按照这个模型的约定来进行实现。Java提供了[Volatile](http://www.codeceo.com/article/java-volatile-var.html)、synchronized、final等机制来帮助开发者保证多线程程序在所有处理器平台上的正确性。

重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译器重排序和运行期重排序，分别对应编译时和运行时环境。

JMM通过happens-before法则保证顺序执行语义，如果想要让执行操作B的线程观察到执行操作A的线程的结果，那么A和B就必须满足happens-before原则，否则，

**JVM可以对它们进行任意排序以提高程序性能。**

volatile关键字可以**保证变量的可见性**，因为对volatile的操作都在Main Memory中，而Main Memory是被所有线程所共享的，这里的代价就是牺牲了性能，无法利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读。

volatile还有一个作用就是**局部阻止重排序的发生**，对volatile变量的操作指令都不会被重排序，因为如果重排序，又可能产生可见性问题。

在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。但是实现方式略有不同，例如同步锁保证得到锁时从内存里重新读入数据刷新缓存，释放锁时将数据写回内存以保数据可见，而volatile变量干脆都是读写内存。

引用:[http://www.codeceo.com/article/javamemorymodel.html](http://www.codeceo.com/article/javamemorymodel.html)

