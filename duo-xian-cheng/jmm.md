JMM介绍

核心概念： 原子性、可见性、重排序、缓存、线程优化、指令重排序、数据安全

JMM Java内存模型,是JVM平台提供给多线程环境下的内存可见、是否可以重排序等无关平台的统一的保证。

Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：

（1）Java内存模型将内存分为了**主内存和工作内存**。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去

（2）定义了几个原子操作，用于操作主内存和工作内存中的变量

（3）定义了volatile变量的使用规则

（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的



#### 多线程开发需要注意3个问题：

原子性、可见性、重排序

原子性是指线程在进行操作的时候是否会受到其他线程的干扰，比如i++操作,是一个复合的操作，如果不能保证原子性，会导致数据安全的问题。

可见性和重排序都是线程优化的问题。

可见性指的是缓存的一致性的问题,CPU都配置了多级高速的缓存来提高性能

典型的CPU缓存结构示意图如下

![](http://static.codeceo.com/images/2017/05/cpu-arch.png)

CPU的指令周期通常为取指令、解析指令读取数据、执行指令、数据写回寄存器或内存。串行执行指令时其中的读取存储数据部分占用时间较长，所以CPU普遍采取指令流水线的方式同时执行多个指令, 提高整体吞吐率，就像工厂流水线一样

#### 重排序

java语言提出了JavaMemoryModel即Java内存模型，对于Java语言、JVM、编译器等实现者需要按照这个模型的约定来进行实现。Java提供了[Volatile](http://www.codeceo.com/article/java-volatile-var.html)、synchronized、final等机制来帮助开发者保证多线程程序在所有处理器平台上的正确性。

重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译器重排序和运行期重排序，分别对应编译时和运行时环境。

JMM通过happens-before法则保证顺序执行语义，如果想要让执行操作B的线程观察到执行操作A的线程的结果，那么A和B就必须满足happens-before原则，否则，

**JVM可以对它们进行任意排序以提高程序性能。**

volatile关键字可以**保证变量的可见性**，因为对volatile的操作都在Main Memory中，而Main Memory是被所有线程所共享的，这里的代价就是牺牲了性能，无法利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读。

volatile还有一个作用就是**局部阻止重排序的发生**，对volatile变量的操作指令都不会被重排序，因为如果重排序，又可能产生可见性问题。

在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。但是实现方式略有不同，例如同步锁保证得到锁时从内存里重新读入数据刷新缓存，释放锁时将数据写回内存以保数据可见，而volatile变量干脆都是读写内存。

引用:[http://www.codeceo.com/article/javamemorymodel.html](http://www.codeceo.com/article/javamemorymodel.html)

