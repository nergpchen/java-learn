一介绍

而在当前的 Java 内存模型下，线程可以把变量保存**本地内存**（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**

Volatile关键词就是告诉jvm，这个变量不稳定，需要直接从主存中读取，保持数据的一致性。　

### 二 volatile关键字的可见性 {#二-volatile关键字的可见性}

**volatile 修饰的成员变量**在每次被线程访问时，都强迫**从主存（共享内存）中重读该成员变量的值**。而且，当成员变量发生变化时，**强迫线程将变化值回写到主存（共享内存）**。这样在任何时刻，**两个不同的线程总是看到某个成员变量的同一个值**，这样也就保证了同步数据的**可见性**。

### 三 volatile关键字能保证原子性吗 {#三-volatile关键字能保证原子性吗}

不能  保证原子性

### 四 synchronized关键字和volatile关键字比较 {#四-synchronized关键字和volatile关键字比较}

* **volatile关键字**
  是线程同步的
  **轻量级实现**
  ，所以
  **volatile性能肯定比synchronized关键字要好**
  。但是
  **volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块**
  。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，
  **实际开发中使用synchronized关键字还是更多一些**
  。
* **多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞**
* **volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。**
* **volatile关键字用于解决变量在多个线程之间的可见性，而ynchronized关键字解决的是多个线程之间访问资源的同步性。**



