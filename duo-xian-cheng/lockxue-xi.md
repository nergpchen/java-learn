#### 一Lock是什么?

Lock是对通过多个线程对共享资源的访问的工具.  
通常，锁提供对共享资源的独占访问：一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。  
 但是，一些锁可能允许并发访问共享资源，如ReadWriteLock的读写锁。

### 1.2 Lock的简单使用 {#12-lock的简单使用}

```
 Lock lock = new ReentrantLock();
 lock.lock();
 try{
 
 }finally{
 lock.unlock();
 }

```

###  1.3 Lock接口的特性和常见方法

**Lock接口提供的synchronized关键字不具备的主要特性：**

|  | 描述 |
| :--- | :--- |
| 尝试非阻塞地获取锁 | 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 |
| 能被中断地获取锁 | 获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 |
| 超时获取锁 | 在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回 |

**Lock接口基本的方法：**

| 方法名称 | 描述 |
| :--- | :--- |
| void lock\(\) | 获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。 |
| void lockInterruptibly\(\) | 获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock\(\)方法不同的是在锁的获取中可以中断当前线程（相应中断）。 |
| Condition newCondition\(\) | 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait\(\)方法，而调用后，当前线程将释放锁。 |
| boolean tryLock\(\) | 只有在调用时才可以获得锁。如果可用，则获取锁定，并立即返回值为true；如果锁不可用，则此方法将立即返回值为false 。 |
| boolean tryLock\(long time, TimeUnit unit\) | 超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false. |
| void unlock\(\) | 释放锁。 |

## 二 Lock接口的实现类：ReentrantLock {#二-lock接口的实现类reentrantlock}





