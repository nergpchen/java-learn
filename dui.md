#### 堆Heap

Heap是 jvm最重要的一块，是存放对象的地方，因为开销最大，也是最影响性能的地方,那么垃圾回收算法也是针对堆的对象进行的.

所以堆的设计、怎么生成对象、怎么回收对象是影响性能的关键，jvm调优也是针对jvm的堆空间的管理.

堆分为新生代和老年代，新生代是存放新的对象，通常存活时间比较短，而老年代是存放存活时间长的对象.

针对新生代用复制算法来回收，老年代由标记算法来回收.

#### 新生代

我们来看看下图,新生代分为Eden ,S1, S2 3个区. 新建的对象先进入Eden区,当Eden满了后，对象进入S1区，当S1区满了后，则要进行垃圾回收,把Eden对象和S1对象先复制到S2,在对Eden、S1进行清理,  
新生代的默认比例为:大小比例默认为8:1:1.

#### 老年代:

老年代的对象都是存活多次，需要用到的概率大，所以使用了另外一种算法标记:所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行**合并**，要么**标记出来便于下次进行分配**，总之就是要减少内存碎片带来的效率损耗

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

![](/assets/jvm2.png)

堆分类:

#### 使用 注意:

1.大对象分配可以通过jvm参赛：-XX:PretenureSizeThreshold 进行设置，因为Eden是存放新对象的，如果是大对象分配到Eden，就会占用空间，降低效率，那么可以直接进入到老年代区域.

  

新生代：存放新生成的对象，新生代通常**存活时间较短**，因此基于**复制算法**来进行回收，所谓**复制算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中.**

老生代：存放结果多次垃圾回收还存在的对象,对象存活的时间比较长，比较稳定，因此采用**标记（Mark）算法**来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行**合并**，要么**标记出来便于下次进行分配**

，总之就是要减少内存碎片带来的效率损耗

堆的内存模型大致为：

![](/assets/gc.png)

新生代分配1/3空间，老年代 2/3堆空间.新生代里的Eden占8/10,from,to各占1/10.

其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。

