**新建\(new\)**

1. ：新创建了一个线程对象。
2. **可运行\(runnable\)**
   ：线程对象创建后，其他线程\(比如main线程）调用了该对象的start\(\)方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。
3. **运行\(running\)**
   ：可运行状态\(runnable\)的线程获得了cpu时间片（timeslice），执行程序代码。
4. **阻塞\(block\)**
   ：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行\(runnable\)状态，才有 机会再次获得cpu timeslice转到运行\(running\)状态。阻塞的情况分三种： \(一\). 等待阻塞：运行\(running\)的线程执行o.wait\(\)方法，JVM会把该线程放 入等待队列\(waitting queue\)中。 \(二\). 同步阻塞：运行\(running\)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池\(lock pool\)中。 \(三\). 其他阻塞: 运行\(running\)的线程执行Thread.sleep\(long ms\)或t.join\(\)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep\(\)状态超时join\(\)等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行\(runnable\)状态。
5. **死亡\(dead\)**
   ：线程run\(\)、main\(\)方法执行结束，或者因异常退出了run\(\)方法，则该线程结束生命周期。死亡的线程不可再次复生。

[![](https://camo.githubusercontent.com/5b764ff5af6204f82c7ae6237b20c41f9505aef8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f392f313635316631396437633465393361333f773d38373626683d34393226663d706e6726733d313238303932)](https://camo.githubusercontent.com/5b764ff5af6204f82c7ae6237b20c41f9505aef8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f392f313635316631396437633465393361333f773d38373626683d34393226663d706e6726733d313238303932)



