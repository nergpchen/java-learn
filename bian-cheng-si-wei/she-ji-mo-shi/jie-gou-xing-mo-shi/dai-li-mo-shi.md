#### 什么是代理模式

代理模式就是给对象提供一个代理对象，通过这个对象来对真实对象进行访问，屏蔽对真实对象的直接访问.

通常 分为静态代理和动态代理

优点 和缺点

#### 结构图:

#### ![](/assets/proxy.png)



#### 角色

Subject:调用代理对象的类，通过代理对象来对真实对象进行访问.

ProxySubject:包含了对`真实（委托）对象(RealSubject)`的引用，可以控制对`RealSubject`的使用，负责在需要的时候创建和删除，并对`RealSubject`的使用加以约束

RealSubject:RealObject所代表的真实对象，也是最终引用的对象

#### 使用场景 

* 远程代理：为对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。比如说 
  WebService
  ，当我们在应用程序的项目中加入一个 
  Web
   引用，引用一个 
  WebService
  ，此时会在项目中声称一个 
  WebReference
   的文件夹和一些文件，这个就是起代理作用的，这样可以让那个客户端程序调用代理解决远程访问的问题；
* 虚拟代理：对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理，这样就可以达到性能的最优化。比如打开一个网页，这个网页里面包含了大量的文字和图片，但我们可以很快看到文字，但是图片却是一张一张地下载后才能看到，那些未打开的图片框，就是通过虚拟代里来替换了真实的图片，此时代理存储了真实图片的路径和尺寸；
* 安全代理：控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候；
* 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化
 
   系统性能。
* 智能引用
  **:**
  指当调用真实的对象时，代理处理另外一些事。比如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它，或当第一次引用一个持久对象时，将它装入内存，或是在访问一个实际对象前，检查是否已经释放它，以确保其他对象不能改变它。这些都是通过代理在访问一个对象时附加一些内务处理；

#### 实现代码

分为静态代理和动态代理。

静态代理是在编译的时候生成代理类。

动态代理是在运行的时候生成代理字节码，并由类加载器加载

JDK动态代理:

   1.uml图 ![](/assets/dymaicproxy.png)JDK动态代理角色:

   1:subject  
   2: InvocationHandler  
   3: RealSubject  
   4: SubjectHandler

SubjectHandler实现InvocationHandler接口

常见案例

