1介绍

事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面。

![](https://user-gold-cdn.xitu.io/2018/5/20/1637b43a47916b2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 "事务属性")

#### 2.TransactionDefinition接口

public interface TransactionDefinition {

```
// 返回事务的传播行为

int getPropagationBehavior\(\); 

// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据

int getIsolationLevel\(\);    

//返回事务的名字

String getName\(\)；
```

// 返回事务必须在多少秒内完成

```
int getTimeout\(\);  

// 返回是否优化为只读事务。

boolean isReadOnly\(\);
```

}  


### 1）事务隔离级别（定义了一个事务可能受其他并发事务影响的程度）：

我们先来看一下 **并发事务带来的问题** ，然后再来介绍一下 **TransactionDefinition 接口** 中定义了五个表示隔离级别的常量。

> #### 并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致一下的问题。

* **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

* **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

  例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

* **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

* **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复度和幻读区别：**

不可重复读的重点是修改，幻读的重点在于新增或者删除。

例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。

例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

#### 隔离级别

TransactionDefinition 接口中定义了五个表示隔离级别的常量：

* **TransactionDefinition.ISOLATION\_DEFAULT:**
   使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE\_READ隔离级别 Oracle 默认采用的 READ\_COMMITTED隔离级别.
* **TransactionDefinition.ISOLATION\_READ\_UNCOMMITTED:**
   最低的隔离级别，允许读取尚未提交的数据变更，
  **可能会导致脏读、幻读或不可重复读**
* **TransactionDefinition.ISOLATION\_READ\_COMMITTED:**
   允许读取并发事务已经提交的数据，
  **可以阻止脏读，但是幻读或不可重复读仍有可能发生**
* **TransactionDefinition.ISOLATION\_REPEATABLE\_READ:**
   对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，
  **可以阻止脏读和不可重复读，但幻读仍有可能发生。**
* **TransactionDefinition.ISOLATION\_SERIALIZABLE:**
   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，
  **该级别可以防止脏读、不可重复读以及幻读**
  。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

### \(3\) 事务超时属性\(一个事务允许执行的最长时间\)

所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。

### \(4\) 事务只读属性（对事物资源是否执行只读操作）

事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。

### \(5\) 回滚规则（定义事务回滚规则）

这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。





